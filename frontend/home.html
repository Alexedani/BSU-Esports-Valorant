<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Valorant Ranked Tracking Tool</title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body>
  <!-- Background -->
  <img src="esports-arena.webp" alt="Valorant Background" class="background"/>

  <!-- Logo -->
  <div class="logo-container">
    <img src="bsu-logo-esports.webp" alt="Boise State Logo" class="logo"/>
  </div>

  <!-- Loading Screen -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-box">
      <p>üîÑ Connecting to server...</p>
    </div>
  </div>

  <!-- Main Card -->
  <div class="card">
    <!-- help button -->
    <button class="help-btn" aria-label="Help" onclick="toggleHelp(true)">?</button>

    <h1>Valorant Ranked Tracking</h1>

    <!-- Add Player Form -->
    <div class="form-group">
      <input type="text" id="playerName" placeholder="Player Name"/>
      <input type="text" id="playerTag" placeholder="Tag"/>
      <button onclick="addPlayer()">Add Player</button>
    </div>


    <div class="table-container">
      <table id="playersTable">
        <thead>
          <tr>
            <th>Player Name</th>
            <th>Tag</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <!-- players are gonna be added here -->
        </tbody>
      </table>
    </div>

    <button class="scrape-btn" onclick="runScraper()">Run Script</button>
  </div>

  <!-- Terminal box-->
  <div id="terminal" title="Scroll to view history"></div>

  <!--info overlay-->
  <div id="helpOverlay" class="help-overlay" onclick="toggleHelp(false)">
    <div class="help-modal" role="dialog" aria-modal="true" onclick="event.stopPropagation()">
      <div class="help-header">
        <h3>About this tool</h3>
        <button class="help-close" aria-label="Close" onclick="toggleHelp(false)">&times;</button>
      </div>
      <div class="help-body">
        <h4>What is this tool?</h4>
        <p>Tracks Valorant ranked data for listed players and sends weekly stats to our Google Sheet.</p>

        <h4>How to use it</h4>
        <ol>
          <li>Add players by name + tag (e.g., <code>master</code> / <code>bsu</code>).</li>
          <li>Click <strong>Run Script</strong> and watch the terminal.</li>
          <li>When done, click <strong>View Results</strong> to open the sheet.</li>
        </ol>

        <h4>Where are results?</h4>
        <p> Results are stored in this 
          <a href="https://docs.google.com/spreadsheets/d/1S1U5COnCPvDH9tTQLk-1Bk2bTJ_ITrC4tSq32LDcBh8/edit#gid=0" target="_blank" rel="noopener">
            Google Sheet
          </a>
          .
        </p>
        <p>The generated sheet will be named whatever the current date is</p>
        <p>Please don't share this sheet with anyone.</p>

        <h4>Need help?</h4>
        <p>If there are any issues, DM me on discord or email me</p>
        <p>Email: alexanderdaniluc@u.boisestate.edu</p>
        <p>Discord: ".turbostar"</p>


        <h4>Misc Notes</h4>
        <ul>
          <li>You can scroll in the terminal to view all the logs.</li>

        </ul>

        <h4>Features I plan/want to add:</h4>
        <ul>
          <li>Configure to run automatically (e.g. once a week)</li>
          <li>Way to add players much quicker via a file upload with the player names</li>
          <li>Dashboard built into the site for viewing player results instead of google sheet</li>
          <li>Expand tracking/scouting to opponents.</li>
          <li>Could expand this to include Rocket leauge and overwatch all in one tool/webapp?</li>
        </ul>
      </div>
    </div>
  </div>

<script>
  const BASE_URL = "https://bsu-esports-valorant.onrender.com";
  const SHEET_URL = "https://docs.google.com/spreadsheets/d/1S1U5COnCPvDH9tTQLk-1Bk2bTJ_ITrC4tSq32LDcBh8/edit#gid=0";

  let pollInterval;
  let scraperRunning = false; // local flag synced with backend

  // --------------- Helpers (terminal) ---------------
  function prune(term) {
    if (term.childNodes.length > 50) term.removeChild(term.firstChild);
    term.scrollTop = term.scrollHeight;
  }

  function appendLog(msg) {
    const term = document.getElementById("terminal");
    const line = document.createElement("div");
    line.innerText = msg;
    term.appendChild(line);
    prune(term);
  }

  function appendLinkToLog(url, text = "View Results") {
    const term = document.getElementById("terminal");
    const line = document.createElement("div");
    line.append("üîó ");
    const a = document.createElement("a");
    a.href = url;
    a.target = "_blank";
    a.rel = "noopener";
    a.innerText = text;
    a.style.color = "#0f0";
    line.appendChild(a);
    term.appendChild(line);
    prune(term);
  }

  function clearTerminal(color = "#0f0") {
    const term = document.getElementById("terminal");
    term.innerHTML = "";
    term.style.color = color; // default green text
  }

  // --------------- Player Management ---------------
  async function addPlayer() {
    if (scraperRunning) {
      appendLog("‚ö† Cannot add players while scraper is running");
      return;
    }

    const name = document.getElementById("playerName").value.trim();
    const tag  = document.getElementById("playerTag").value.trim();

    if (!name || !tag) {
      appendLog("‚ö† Enter both name and tag!");
      return;
    }

    if (tag.includes("#")) {
      appendLog("‚ö† Do not include '#' in the tag ‚Äî just the part after it.");
      return;
    }

    try {
      const res = await fetch(`${BASE_URL}/save-player`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, tag })
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error("Add player failed:", res.status, txt);
        appendLog(`‚ùå Error adding player: ${res.status}`);
        return;
      }

      await renderPlayers();
      document.getElementById("playerName").value = "";
      document.getElementById("playerTag").value  = "";
      appendLog(`‚úÖ Added player ${name}#${tag}`);
    } catch (err) {
      console.error("Add player network error:", err);
      appendLog("‚ùå Network error adding player");
    }
  }

  async function removePlayer(name) {
    if (scraperRunning) {
      appendLog("‚ö† Cannot remove players while scraper is running");
      return;
    }
    try {
      const res = await fetch(`${BASE_URL}/remove-player`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name })
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error("Remove player failed:", res.status, txt);
        appendLog(`‚ùå Error removing player: ${res.status}`);
        return;
      }

      await renderPlayers();
    } catch (err) {
      console.error("Remove player network error:", err);
      appendLog("‚ùå Network error removing player");
    }
  }

  async function renderPlayers() {
    const tbody = document.querySelector("#playersTable tbody");
    tbody.innerHTML = "";

    try {
      const res = await fetch(`${BASE_URL}/players`);
      if (!res.ok) {
        tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">Failed to load players</td></tr>`;
        return;
      }

      const players = await res.json();
      const names = Object.keys(players);

      if (names.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">No players being tracked yet</td></tr>`;
      } else {
        names.forEach((name) => {
          const tag = players[name];
          const row = `
            <tr>
              <td>${name}</td>
              <td>${tag}</td>
              <td class="remove-cell">
                <button class="remove-btn" onclick="removePlayer('${name}')" aria-label="Remove">&times;</button>
              </td>
            </tr>`;
          tbody.insertAdjacentHTML("beforeend", row);
        });
      }
    } catch (err) {
      tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">Network error loading players</td></tr>`;
    } finally {
      // Hide loading screen once we tried loading players
      document.getElementById("loadingOverlay").style.display = "none";
    }
  }

  // --------------- Run Scraper ---------------
  async function runScraper() {
    const btn = document.querySelector(".scrape-btn");
    btn.disabled = true;
    scraperRunning = true;

    clearTerminal();
    appendLog("‚ñ∂ Starting scrape...");

    try {
      const res = await fetch(`${BASE_URL}/run-scraper`, { method: "POST" });
      const data = await res.json();

      if (data.error) {
        clearTerminal("red");
        appendLog("‚ùå " + data.error);
        btn.disabled = false;
        scraperRunning = false;
        return;
      }

      if (pollInterval) clearInterval(pollInterval);
      pollInterval = setInterval(checkStatus, 5000);
      checkStatus();
    } catch (err) {
      clearTerminal("red");
      appendLog("‚ùå Failed to start scraper");
      btn.disabled = false;
      scraperRunning = false;
    }
  }

  async function checkStatus() {
    try {
      const res = await fetch(`${BASE_URL}/scraper-status`);
      const statusData = await res.json();

      if (statusData.logs) {
        const term = document.getElementById("terminal");
        term.innerHTML = "";
        statusData.logs.forEach(l => {
          const line = document.createElement("div");
          line.innerText = l;
          if (l.includes("ERROR")) {
            line.style.color = "red";
          }
          term.appendChild(line);
        });
      }

      if (statusData.progress) {
        appendLog(`Progress: ${statusData.progress.current}/${statusData.progress.total} players scraped`);
      }

      if (statusData.status === "done") {
        clearInterval(pollInterval);
        appendLog("‚úÖ Scrape finished!");
        appendLinkToLog(SHEET_URL);
        document.querySelector(".scrape-btn").disabled = false;
        scraperRunning = false;
      } else if (statusData.status === "error") {
        clearInterval(pollInterval);
        clearTerminal("red");
        appendLog("‚ùå Error while scraping");
        document.querySelector(".scrape-btn").disabled = false;
        scraperRunning = false;
      } else if (statusData.status === "running") {
        scraperRunning = true;
      }
    } catch (err) {
      clearInterval(pollInterval);
      clearTerminal("red");
      appendLog("‚ùå Status check failed");
      document.querySelector(".scrape-btn").disabled = false;
      scraperRunning = false;
    }
  }

  // --------------- Last Results Button ---------------
  async function viewLastResults() {
    try {
      const res = await fetch(`${BASE_URL}/last-results`);
      if (!res.ok) throw new Error("failed");
      appendLog("üìä Last scrape results available:");
      appendLinkToLog(SHEET_URL, "Open Google Sheet");
    } catch (err) {
      clearTerminal("red");
      appendLog("‚ùå Failed to load last results");
    }
  }

  // --------------- Help & Auth ---------------
  function toggleHelp(show) {
    const ov = document.getElementById("helpOverlay");
    ov.style.display = show ? "flex" : "none";
  }

  if (localStorage.getItem("loggedIn") !== "true") {
    window.location.href = "index.html";
  }

  // Initial load
  renderPlayers();
</script>



</body>
</html>
