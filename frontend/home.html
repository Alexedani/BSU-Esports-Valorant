<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Valorant Ranked Tracking Tool</title>
  <link rel="stylesheet" href="style.css"/>
</head>
<body>
  <div id="app">

  <!-- todos -->

  <!-- Background -->
  <img src="esports-arena.webp" alt="Valorant Background" class="background"/>

  <!-- Logo -->
  <div class="logo-container">
    <img src="bsu-logo-esports.webp" alt="Boise State Logo" class="logo"/>
  </div>

  <!-- Loading Screen -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-box">
      <p>üîÑ Connecting to server...</p>
    </div>
  </div>

  <!-- Main Card -->
  <div class="card">
    <!-- help button -->
    <button class="help-btn" aria-label="Help" onclick="toggleHelp(true)">?</button>

    <h1>Valorant Ranked Tracking</h1>

    <!-- Add Player Form -->
    <div class="form-group">
      <label for="playerFile">Add Players:</label>
      <input type="text" id="playerName" placeholder="Player Name"/>
      <input type="text" id="playerTag" placeholder="Tag"/>
      <button onclick="addPlayer()">Add Player</button>
    </div>

    <div class="form-group">
      <label for="playerFile">Import Players (JSON File):</label>
      <input type="file" id="playerFile" accept=".json" onchange="importPlayers(this)">
    </div>
 

    <div class="table-container">
      <table id="playersTable">
        <thead>
          <tr>
            <th>Player Name</th>
            <th>Tag</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <!-- players are gonna be added here -->
        </tbody>
      </table>
    </div>

    <br/>
    <label for="playerFile">Settings:</label>
    <div class="config-panel">
      <label>
        Days back:
        <input type="number" id="daysBack" value="7" min="1" max="30">
      </label>

      <label>
        Min games:
        <input type="number" id="minGames" value="1" min="1" max="20">
      </label>

      <label>
        <input type="checkbox" id="skipToday">
        Skip today
      </label>
    </div>

    <button class="scrape-btn" onclick="runScraper()">Run Script</button>
    

  </div>

  <!-- Terminal box-->
  <div id="terminal-container" style="position: relative;">

    <div id="terminal" title="Scroll to view history"></div>
    <button class="reset-btn" onclick="resetScraper()">Force Reset</button>
  </div>

  <!--info overlay-->
  <div id="helpOverlay" class="help-overlay" onclick="toggleHelp(false)">
    <div class="help-modal" role="dialog" aria-modal="true" onclick="event.stopPropagation()">
      <div class="help-header">
        <h3>About this tool</h3>
        <button class="help-close" aria-label="Close" onclick="toggleHelp(false)">&times;</button>
      </div>
<div class="help-body">
  <h4>What is this tool?</h4>
  <p>
    This tool tracks Valorant ranked data for the listed players and automatically
    sends stats to our Google Sheet.
  </p>

  <h4>How to use it</h4>
  <ol>
    <li>
      Add players manually by entering <strong>Name</strong> and <strong>Tag</strong>
      (e.g., <code>master</code> / <code>bsu</code>).
      <br><em>Note: Do not include ‚Äú#‚Äù in the tag ‚Äî the system adds it automatically.</em>
    </li>
    <li>
      Or bulk import players from a <strong>JSON file</strong> using the
      <em>Import Players</em> option.  
      <br>Your file should look like:
      <pre>{
  "master": "bsu",
  "prestige": "bsu",
  "skelesis": "Folk"
}</pre>
      Uploading a file will <strong>replace the entire list</strong> of tracked players.
    </li>
    <li>
      Adjust <strong>Settings</strong> (Days Back, Min Games, Skip Today) to control how data is collected.
    </li>
    <li>
      Click <strong>Run Script</strong> to start. Progress and logs will appear in the console below.
    </li>
    <li>
      When finished, click <strong>View Results</strong> to open the Google Sheet.
    </li>
  </ol>

  <h4>Settings Explained</h4>
  <ul>
    <li>
      <strong>Days Back:</strong> Controls how far back in time to collect match data
      (default: 7). 
    </li>
    <li>
      <strong>Min Games:</strong> Filters out agents that were only played a small number
      of times. For example, setting it to 3 ensures only agents with at least 3 matches
      are shown.
    </li>
    <li>
      <strong>Skip Today:</strong> Ignores matches from the current day, so only
      completed full days are included. This is useful for weekly reporting if the script is ran earlier in the day and not all players have played yet or finished playing that day.
    </li>
  </ul>

  <h4>Important Notes</h4>
  <ul>
    <li>You cannot add or remove players while a scrape is running.</li>
    <li>If a player does not exist or their profile is hidden, the script will abort and no results will be posted.</li>
    <li>Re-importing a JSON file (even the same one) always overwrites the player list.</li>
    <li>The script may take several minutes per player depending on their recent match history.</li>
  </ul>

  <h4>Where are results?</h4>
  <p>
    Results are stored in this
    <a href="https://docs.google.com/spreadsheets/d/1S1U5COnCPvDH9tTQLk-1Bk2bTJ_ITrC4tSq32LDcBh8/edit#gid=0"
       target="_blank" rel="noopener">Google Sheet</a>.
  </p>
  <p>The generated sheet will be named with the current date.</p>
  <p>Please do not share this sheet outside the team.</p>

  <h4>Need help?</h4>
  <p>If there are any issues, contact Alex:</p>
  <ul>
    <li>Email: <a href="mailto:alexanderdaniluc@u.boisestate.edu">alexanderdaniluc@u.boisestate.edu</a></li>
    <li>Discord: <code>.turbostar</code></li>
  </ul>
</div>


    </div>
  </div>

<script>
  const BASE_URL = "https://bsu-esports-valorant.onrender.com";
  const SHEET_URL = "https://docs.google.com/spreadsheets/d/1S1U5COnCPvDH9tTQLk-1Bk2bTJ_ITrC4tSq32LDcBh8/edit#gid=0";

  let pollInterval;
  let scraperRunning = false; // local flag synced with backend

  // --------------- Helpers (terminal) ---------------
  function prune(term) {
    if (term.childNodes.length > 50) term.removeChild(term.firstChild);
    term.scrollTop = term.scrollHeight;
  }

  function appendLog(msg) {
    const term = document.getElementById("terminal");
    const line = document.createElement("div");
    line.innerText = msg;
    term.appendChild(line);
    prune(term);
  }

  function appendLinkToLog(url, text = "View Results") {
    const term = document.getElementById("terminal");
    const line = document.createElement("div");
    line.append("üîó ");
    const a = document.createElement("a");
    a.href = url;
    a.target = "_blank";
    a.rel = "noopener";
    a.innerText = text;
    a.style.color = "#0f0";
    line.appendChild(a);
    term.appendChild(line);
    prune(term);
  }

  function clearTerminal(color = "#0f0") {
    const term = document.getElementById("terminal");
    term.innerHTML = "";
    term.style.color = color; // default green text
  }

  // --------------- Player Management ---------------
  async function addPlayer() {
    if (scraperRunning) {
      appendLog("‚ö† Cannot add players while scraper is running");
      return;
    }

    const name = document.getElementById("playerName").value.trim();
    const tag  = document.getElementById("playerTag").value.trim();

    if (!name || !tag) {
      appendLog("‚ö† Enter both name and tag!");
      return;
    }

    if (tag.includes("#")) {
      appendLog("‚ö† Do not include '#' in the tag ‚Äî just the part after it.");
      return;
    }

    try {
      const res = await fetch(`${BASE_URL}/save-player`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, tag })
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error("Add player failed:", res.status, txt);
        appendLog(`‚ùå Error adding player: ${res.status}`);
        return;
      }

      await renderPlayers();
      document.getElementById("playerName").value = "";
      document.getElementById("playerTag").value  = "";
      appendLog(`‚úÖ Added player ${name}#${tag}`);
    } catch (err) {
      console.error("Add player network error:", err);
      appendLog("‚ùå Network error adding player");
    }
  }

  async function removePlayer(name) {
    if (scraperRunning) {
      appendLog("‚ö† Cannot remove players while scraper is running");
      return;
    }
    try {
      const res = await fetch(`${BASE_URL}/remove-player`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name })
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error("Remove player failed:", res.status, txt);
        appendLog(`‚ùå Error removing player: ${res.status}`);
        return;
      }

      await renderPlayers();
    } catch (err) {
      console.error("Remove player network error:", err);
      appendLog("‚ùå Network error removing player");
    }
  }

  async function renderPlayers() {
    const tbody = document.querySelector("#playersTable tbody");
    tbody.innerHTML = "";

    try {
      const res = await fetch(`${BASE_URL}/players`);
      if (!res.ok) {
        tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">Failed to load players</td></tr>`;
        return;
      }

      const players = await res.json();
      const names = Object.keys(players);

      if (names.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">No players being tracked yet</td></tr>`;
      } else {
        names.forEach((name) => {
          const tag = players[name];
          const row = `
            <tr>
              <td>${name}</td>
              <td>${tag}</td>
              <td class="remove-cell">
                <button class="remove-btn" onclick="removePlayer('${name}')" aria-label="Remove">&times;</button>
              </td>
            </tr>`;
          tbody.insertAdjacentHTML("beforeend", row);
        });
      }
    } catch (err) {
      tbody.innerHTML = `<tr><td colspan="3" class="empty-msg">Network error loading players</td></tr>`;
    } finally {
      // Hide loading screen once we tried loading players
      document.getElementById("loadingOverlay").style.display = "none";
    }
  }

  // --------------- Run Scraper ---------------
  async function runScraper() {
    const btn = document.querySelector(".scrape-btn");
    btn.disabled = true;
    scraperRunning = true;

    clearTerminal();
    appendLog("‚ñ∂ Starting scrape...");

    const settings = {
      daysBack: parseInt(document.getElementById("daysBack").value, 10) || 7,
      minGames: parseInt(document.getElementById("minGames").value, 10) || 1,
      skipToday: document.getElementById("skipToday").checked
    };

    try {
      const res = await fetch(`${BASE_URL}/run-scraper`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(settings)
      });
      const data = await res.json();

      if (data.error) {
        clearTerminal("red");
        appendLog("‚ùå " + data.error);
        btn.disabled = false;
        scraperRunning = false;
        return;
      }

      if (pollInterval) clearInterval(pollInterval);
      pollInterval = setInterval(checkStatus, 5000);
      checkStatus();
    } catch (err) {
      clearTerminal("red");
      appendLog("‚ùå Failed to start scraper");
      btn.disabled = false;
      scraperRunning = false;
    }
  }

  async function checkStatus() {
    try {
      const res = await fetch(`${BASE_URL}/scraper-status`);
      const statusData = await res.json();

      if (statusData.logs) {
        const term = document.getElementById("terminal");
        term.innerHTML = "";
        statusData.logs.forEach(l => {
          const line = document.createElement("div");
          line.innerText = l;
          if (l.includes("ERROR")) {
            line.style.color = "red";
          }
          term.appendChild(line);
        });
      }

      // üõë If scraper aborted, stop immediately
      if (statusData.status === "aborted") {
        clearInterval(pollInterval);
        appendLog("‚ùå Scraper aborted due to errors ‚Äî no data posted.");
        document.querySelector(".scrape-btn").disabled = false;
        scraperRunning = false;
        return;
      }

      // Normal progress only if not aborted
      if (statusData.progress && statusData.status === "running") {
        appendLog(
          `Progress: ${statusData.progress.current}/${statusData.progress.total} players scraped`
        );
      }

      if (statusData.status === "done") {
        clearInterval(pollInterval);
        appendLog("‚úÖ Scrape finished!");
        appendLinkToLog(SHEET_URL);
        document.querySelector(".scrape-btn").disabled = false;
        scraperRunning = false;
      } else if (statusData.status === "error") {
        clearInterval(pollInterval);
        appendLog("‚ùå Error while scraping");
        document.querySelector(".scrape-btn").disabled = false;
        scraperRunning = false;
      } else if (statusData.status === "running") {
        scraperRunning = true;
      }
    } catch (err) {
      clearInterval(pollInterval);
      appendLog("‚ùå Status check failed");
      document.querySelector(".scrape-btn").disabled = false;
      scraperRunning = false;
    }
  }


  // --------------- Last Results Button ---------------
  async function viewLastResults() {
    try {
      const res = await fetch(`${BASE_URL}/last-results`);
      if (!res.ok) throw new Error("failed");
      appendLog("üìä Last scrape results available:");
      appendLinkToLog(SHEET_URL, "Open Google Sheet");
    } catch (err) {
      clearTerminal("red");
      appendLog("‚ùå Failed to load last results");
    }
  }

  // --------------- Help & Auth ---------------
  function toggleHelp(show) {
    const ov = document.getElementById("helpOverlay");
    ov.style.display = show ? "flex" : "none";
  }

  if (localStorage.getItem("loggedIn") !== "true") {
    window.location.href = "index.html";
  }

  async function importPlayers(input) {
    const file = input.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const data = JSON.parse(e.target.result);

        if (typeof data !== "object" || Array.isArray(data)) {
          appendLog("‚ùå Invalid file format. Expected {name: tag}");
          input.value = ""; // reset
          return;
        }

        const res = await fetch(`${BASE_URL}/bulk-add-players`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data)
        });

        if (!res.ok) {
          const txt = await res.text();
          appendLog("‚ùå Bulk add failed: " + txt);
        } else {
          appendLog(`‚úÖ Imported ${Object.keys(data).length} players`);
          await renderPlayers();
        }
      } catch (err) {
        appendLog("‚ùå Error parsing file: " + err.message);
      } finally {
        input.value = ""; 
      }
    };
    reader.readAsText(file);
  }

  async function resetScraper() {
    if (scraperRunning) {
      appendLog("Aborting current scrape and resetting...");
    } else {
      appendLog("No active scrape. Resetting state anyway...");
    }

    try {
      const res = await fetch(`${BASE_URL}/reset-scraper`, { method: "POST" });
      if (!res.ok) {
        appendLog("‚ùå Failed to reset scraper");
        return;
      }
      const data = await res.json();
      appendLog("‚úÖ Scraper state reset complete.");
      scraperRunning = false;
      document.querySelector(".scrape-btn").disabled = false;
      if (pollInterval) clearInterval(pollInterval);
    } catch (err) {
      appendLog("‚ùå Network error resetting scraper");
    }
  }



  // Initial load
  renderPlayers();
</script>


</div>
</body>
</html>
